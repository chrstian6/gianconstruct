"use server";

import { revalidatePath } from "next/cache";
import dbConnect from "@/lib/db";
import Supplier, { ISupplierDocument } from "@/models/Supplier";
import { ISupplier, SupplierFormData } from "@/types/supplier";

// Helper function to convert Mongoose document to ISupplier
const convertToISupplier = (doc: any): ISupplier => ({
  supplier_id: doc.supplier_id,
  companyName: doc.companyName,
  contactPerson: doc.contactPerson,
  contact: doc.contact,
  email: doc.email,
  location: doc.location,
  status: doc.status,
  _id: doc._id?.toString(),
  createdAt: doc.createdAt,
  updatedAt: doc.updatedAt,
});

export async function getSuppliers(): Promise<ISupplier[]> {
  try {
    await dbConnect();
    const suppliers = await Supplier.find({}).sort({ createdAt: -1 }).lean();

    // Properly type and map the suppliers
    return suppliers.map((supplier) => convertToISupplier(supplier));
  } catch (error) {
    console.error("Error fetching suppliers:", error);
    throw new Error("Failed to fetch suppliers");
  }
}

export async function getSupplierById(
  supplier_id: string
): Promise<ISupplier | null> {
  try {
    await dbConnect();
    const supplier = await Supplier.findOne({ supplier_id }).lean();
    if (!supplier) return null;

    return convertToISupplier(supplier);
  } catch (error) {
    console.error("Error fetching supplier:", error);
    throw new Error("Failed to fetch supplier");
  }
}

// Create a new supplier with auto-generated supplier_id
export async function createSupplier(
  formData: SupplierFormData
): Promise<{ success: boolean; supplier?: ISupplier; error?: string }> {
  try {
    await dbConnect();

    // Validate contact format
    if (!/^\d{11}$/.test(formData.contact)) {
      return {
        success: false,
        error: "Contact must be exactly 11 digits",
      };
    }

    // Explicitly exclude supplier_id from formData
    const { companyName, contactPerson, contact, email, location, status } =
      formData;
    const supplierData = {
      companyName,
      contactPerson,
      contact,
      email,
      location,
      status,
    };

    console.log("Creating supplier with data:", supplierData); // Debugging

    // Create supplier (supplier_id should be generated by pre-save middleware)
    const supplier = new Supplier(supplierData);

    // Log the supplier before saving to verify supplier_id
    console.log("Supplier before save:", supplier.toObject());

    // Fallback: Generate supplier_id if middleware fails
    if (!supplier.supplier_id) {
      console.warn(
        "Middleware did not set supplier_id, generating fallback ID"
      );
      const lastSupplier = (await Supplier.findOne()
        .sort({ supplier_id: -1 })
        .lean()
        .exec()) as ISupplierDocument | null;
      let nextNumber = 1;
      if (lastSupplier && lastSupplier.supplier_id) {
        const match = lastSupplier.supplier_id.match(/^SUP-(\d+)$/);
        if (match && match[1]) {
          nextNumber = parseInt(match[1], 10) + 1;
        }
      }
      supplier.supplier_id = `SUP-${nextNumber.toString().padStart(6, "0")}`;
      console.log("Fallback supplier_id generated:", supplier.supplier_id);
    }

    // Save the supplier
    await supplier.save();

    // Log the saved supplier to confirm supplier_id
    console.log("Supplier after save:", supplier.toObject());

    // Verify supplier_id was set
    if (!supplier.supplier_id) {
      throw new Error("Failed to generate supplier_id");
    }

    revalidatePath("/admin/suppliers");

    return {
      success: true,
      supplier: convertToISupplier(supplier),
    };
  } catch (error: any) {
    console.error("Error creating supplier:", error);
    return {
      success: false,
      error: error.message || "Failed to create supplier",
    };
  }
}

export async function updateSupplier(
  supplier_id: string,
  formData: SupplierFormData
): Promise<{ success: boolean; supplier?: ISupplier; error?: string }> {
  try {
    await dbConnect();

    // Validate contact format
    if (!/^\d{11}$/.test(formData.contact)) {
      return {
        success: false,
        error: "Contact must be exactly 11 digits",
      };
    }

    const supplier = await Supplier.findOneAndUpdate(
      { supplier_id },
      { ...formData, updatedAt: new Date() },
      { new: true, runValidators: true }
    );

    if (!supplier) {
      return {
        success: false,
        error: "Supplier not found",
      };
    }

    revalidatePath("/admin/suppliers");

    return {
      success: true,
      supplier: convertToISupplier(supplier),
    };
  } catch (error: any) {
    console.error("Error updating supplier:", error);
    return {
      success: false,
      error: error.message || "Failed to create supplier",
    };
  }
}

export async function deleteSupplier(
  supplier_id: string
): Promise<{ success: boolean; error?: string }> {
  try {
    await dbConnect();

    const result = await Supplier.findOneAndDelete({ supplier_id });

    if (!result) {
      return {
        success: false,
        error: "Supplier not found",
      };
    }

    revalidatePath("/admin/suppliers");

    return {
      success: true,
    };
  } catch (error: any) {
    console.error("Error deleting supplier:", error);
    return {
      success: false,
      error: error.message || "Failed to delete supplier",
    };
  }
}
